<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=cGvuclDC_Z1vE_cnVEU6Ae_NZQ7StBcqH_vXVqoPMX0');.lst-kix_6d3ij62w2wog-8>li:before{content:"\0025a0  "}.lst-kix_tnb5cty5lfmx-7>li:before{content:"\0025cb  "}.lst-kix_tnb5cty5lfmx-6>li:before{content:"\0025cf  "}ul.lst-kix_tnb5cty5lfmx-0{list-style-type:none}ul.lst-kix_tnb5cty5lfmx-1{list-style-type:none}.lst-kix_tnb5cty5lfmx-8>li:before{content:"\0025a0  "}ul.lst-kix_hd03wv7eqjkl-2{list-style-type:none}.lst-kix_tnb5cty5lfmx-0>li:before{content:"\0025cf  "}ul.lst-kix_tnb5cty5lfmx-6{list-style-type:none}ul.lst-kix_ioj6prcymh7w-5{list-style-type:none}ul.lst-kix_hd03wv7eqjkl-1{list-style-type:none}ul.lst-kix_tnb5cty5lfmx-7{list-style-type:none}ul.lst-kix_ioj6prcymh7w-4{list-style-type:none}ul.lst-kix_hd03wv7eqjkl-0{list-style-type:none}.lst-kix_tnb5cty5lfmx-1>li:before{content:"\0025cb  "}ul.lst-kix_tnb5cty5lfmx-8{list-style-type:none}ul.lst-kix_ioj6prcymh7w-7{list-style-type:none}.lst-kix_6qphcg6049xm-5>li:before{content:"\0025a0  "}ul.lst-kix_ioj6prcymh7w-6{list-style-type:none}.lst-kix_tnb5cty5lfmx-2>li:before{content:"\0025a0  "}ul.lst-kix_tnb5cty5lfmx-2{list-style-type:none}ul.lst-kix_tnb5cty5lfmx-3{list-style-type:none}ul.lst-kix_ioj6prcymh7w-8{list-style-type:none}ul.lst-kix_hbudgemy4svg-8{list-style-type:none}ul.lst-kix_tnb5cty5lfmx-4{list-style-type:none}ul.lst-kix_hbudgemy4svg-7{list-style-type:none}ul.lst-kix_tnb5cty5lfmx-5{list-style-type:none}.lst-kix_6qphcg6049xm-6>li:before{content:"\0025cf  "}ul.lst-kix_hbudgemy4svg-6{list-style-type:none}.lst-kix_tnb5cty5lfmx-4>li:before{content:"\0025cb  "}.lst-kix_6d3ij62w2wog-1>li:before{content:"\0025cb  "}ul.lst-kix_hbudgemy4svg-5{list-style-type:none}ul.lst-kix_hbudgemy4svg-4{list-style-type:none}ul.lst-kix_hd03wv7eqjkl-8{list-style-type:none}.lst-kix_tnb5cty5lfmx-3>li:before{content:"\0025cf  "}.lst-kix_tnb5cty5lfmx-5>li:before{content:"\0025a0  "}.lst-kix_6d3ij62w2wog-0>li:before{content:"\0025cf  "}.lst-kix_6d3ij62w2wog-2>li:before{content:"\0025a0  "}ul.lst-kix_hbudgemy4svg-3{list-style-type:none}ul.lst-kix_hd03wv7eqjkl-7{list-style-type:none}.lst-kix_6qphcg6049xm-7>li:before{content:"\0025cb  "}ul.lst-kix_hbudgemy4svg-2{list-style-type:none}ul.lst-kix_hd03wv7eqjkl-6{list-style-type:none}ul.lst-kix_ioj6prcymh7w-1{list-style-type:none}ul.lst-kix_hbudgemy4svg-1{list-style-type:none}ul.lst-kix_hd03wv7eqjkl-5{list-style-type:none}ul.lst-kix_ioj6prcymh7w-0{list-style-type:none}ul.lst-kix_hbudgemy4svg-0{list-style-type:none}ul.lst-kix_hd03wv7eqjkl-4{list-style-type:none}ul.lst-kix_ioj6prcymh7w-3{list-style-type:none}ul.lst-kix_hd03wv7eqjkl-3{list-style-type:none}.lst-kix_6qphcg6049xm-8>li:before{content:"\0025a0  "}ul.lst-kix_ioj6prcymh7w-2{list-style-type:none}ul.lst-kix_ytu4f919d0ss-4{list-style-type:none}.lst-kix_6d3ij62w2wog-5>li:before{content:"\0025a0  "}ul.lst-kix_ytu4f919d0ss-5{list-style-type:none}ul.lst-kix_ytu4f919d0ss-6{list-style-type:none}.lst-kix_6d3ij62w2wog-4>li:before{content:"\0025cb  "}.lst-kix_6d3ij62w2wog-6>li:before{content:"\0025cf  "}ul.lst-kix_ytu4f919d0ss-7{list-style-type:none}ul.lst-kix_ytu4f919d0ss-0{list-style-type:none}.lst-kix_6d3ij62w2wog-3>li:before{content:"\0025cf  "}.lst-kix_6d3ij62w2wog-7>li:before{content:"\0025cb  "}ul.lst-kix_ytu4f919d0ss-1{list-style-type:none}ul.lst-kix_ytu4f919d0ss-2{list-style-type:none}ul.lst-kix_ytu4f919d0ss-3{list-style-type:none}ul.lst-kix_yrtyp8sld7dk-1{list-style-type:none}ul.lst-kix_yrtyp8sld7dk-0{list-style-type:none}ul.lst-kix_yrtyp8sld7dk-3{list-style-type:none}ul.lst-kix_yrtyp8sld7dk-2{list-style-type:none}ul.lst-kix_ytu4f919d0ss-8{list-style-type:none}ul.lst-kix_yrtyp8sld7dk-5{list-style-type:none}ul.lst-kix_yrtyp8sld7dk-4{list-style-type:none}ul.lst-kix_yrtyp8sld7dk-7{list-style-type:none}ul.lst-kix_yrtyp8sld7dk-6{list-style-type:none}.lst-kix_cmozs3kyr76r-1>li:before{content:"\0025cb  "}.lst-kix_cmozs3kyr76r-2>li:before{content:"\0025a0  "}.lst-kix_ytu4f919d0ss-0>li:before{content:"\0025cf  "}.lst-kix_ytu4f919d0ss-1>li:before{content:"\0025cb  "}ul.lst-kix_yrtyp8sld7dk-8{list-style-type:none}.lst-kix_cmozs3kyr76r-0>li:before{content:"\0025cf  "}.lst-kix_cmozs3kyr76r-4>li:before{content:"\0025cb  "}.lst-kix_ytu4f919d0ss-2>li:before{content:"\0025a0  "}.lst-kix_ytu4f919d0ss-4>li:before{content:"\0025cb  "}.lst-kix_ytu4f919d0ss-5>li:before{content:"\0025a0  "}.lst-kix_hd03wv7eqjkl-8>li:before{content:"\0025a0  "}.lst-kix_cmozs3kyr76r-3>li:before{content:"\0025cf  "}.lst-kix_ytu4f919d0ss-3>li:before{content:"\0025cf  "}.lst-kix_hd03wv7eqjkl-7>li:before{content:"\0025cb  "}.lst-kix_hd03wv7eqjkl-4>li:before{content:"\0025cb  "}.lst-kix_hd03wv7eqjkl-6>li:before{content:"\0025cf  "}.lst-kix_hd03wv7eqjkl-1>li:before{content:"\0025cb  "}.lst-kix_hd03wv7eqjkl-5>li:before{content:"\0025a0  "}.lst-kix_hd03wv7eqjkl-2>li:before{content:"\0025a0  "}.lst-kix_hd03wv7eqjkl-3>li:before{content:"\0025cf  "}.lst-kix_6qphcg6049xm-4>li:before{content:"\0025cb  "}.lst-kix_6qphcg6049xm-3>li:before{content:"\0025cf  "}.lst-kix_6qphcg6049xm-2>li:before{content:"\0025a0  "}.lst-kix_6qphcg6049xm-0>li:before{content:"\0025cf  "}ul.lst-kix_gui7t0bb9blf-8{list-style-type:none}ul.lst-kix_gui7t0bb9blf-7{list-style-type:none}.lst-kix_6qphcg6049xm-1>li:before{content:"\0025cb  "}ul.lst-kix_gui7t0bb9blf-6{list-style-type:none}.lst-kix_ytu4f919d0ss-8>li:before{content:"\0025a0  "}.lst-kix_cmozs3kyr76r-8>li:before{content:"\0025a0  "}.lst-kix_ytu4f919d0ss-6>li:before{content:"\0025cf  "}.lst-kix_cmozs3kyr76r-5>li:before{content:"\0025a0  "}.lst-kix_cmozs3kyr76r-6>li:before{content:"\0025cf  "}.lst-kix_cmozs3kyr76r-7>li:before{content:"\0025cb  "}.lst-kix_ytu4f919d0ss-7>li:before{content:"\0025cb  "}.lst-kix_xil4dpzhlcd1-4>li:before{content:"\0025cb  "}ul.lst-kix_ctab4i83amx5-7{list-style-type:none}ul.lst-kix_ctab4i83amx5-6{list-style-type:none}ul.lst-kix_ctab4i83amx5-8{list-style-type:none}.lst-kix_gui7t0bb9blf-3>li:before{content:"\0025cf  "}.lst-kix_xil4dpzhlcd1-2>li:before{content:"\0025a0  "}.lst-kix_yrtyp8sld7dk-2>li:before{content:"\0025a0  "}ul.lst-kix_gui7t0bb9blf-1{list-style-type:none}ul.lst-kix_gui7t0bb9blf-0{list-style-type:none}ul.lst-kix_ctab4i83amx5-1{list-style-type:none}ul.lst-kix_ctab4i83amx5-0{list-style-type:none}ul.lst-kix_ctab4i83amx5-3{list-style-type:none}.lst-kix_ctab4i83amx5-5>li:before{content:"\0025a0  "}ul.lst-kix_gui7t0bb9blf-5{list-style-type:none}ul.lst-kix_ctab4i83amx5-2{list-style-type:none}ul.lst-kix_gui7t0bb9blf-4{list-style-type:none}ul.lst-kix_ctab4i83amx5-5{list-style-type:none}ul.lst-kix_gui7t0bb9blf-3{list-style-type:none}ul.lst-kix_ctab4i83amx5-4{list-style-type:none}ul.lst-kix_gui7t0bb9blf-2{list-style-type:none}.lst-kix_ctab4i83amx5-7>li:before{content:"\0025cb  "}.lst-kix_gui7t0bb9blf-5>li:before{content:"\0025a0  "}.lst-kix_xil4dpzhlcd1-8>li:before{content:"\0025a0  "}.lst-kix_yrtyp8sld7dk-0>li:before{content:"\0025cf  "}.lst-kix_gui7t0bb9blf-7>li:before{content:"\0025cb  "}.lst-kix_xil4dpzhlcd1-6>li:before{content:"\0025cf  "}.lst-kix_yrtyp8sld7dk-6>li:before{content:"\0025cf  "}ul.lst-kix_eczj93c02e14-8{list-style-type:none}ul.lst-kix_eczj93c02e14-7{list-style-type:none}ul.lst-kix_eczj93c02e14-6{list-style-type:none}.lst-kix_yrtyp8sld7dk-4>li:before{content:"\0025cb  "}.lst-kix_ctab4i83amx5-3>li:before{content:"\0025cf  "}ul.lst-kix_eczj93c02e14-1{list-style-type:none}ul.lst-kix_eczj93c02e14-0{list-style-type:none}.lst-kix_ctab4i83amx5-1>li:before{content:"\0025cb  "}ul.lst-kix_eczj93c02e14-5{list-style-type:none}ul.lst-kix_eczj93c02e14-4{list-style-type:none}ul.lst-kix_eczj93c02e14-3{list-style-type:none}ul.lst-kix_eczj93c02e14-2{list-style-type:none}.lst-kix_xil4dpzhlcd1-0>li:before{content:"\0025cf  "}.lst-kix_yrtyp8sld7dk-8>li:before{content:"\0025a0  "}ul.lst-kix_6qphcg6049xm-7{list-style-type:none}.lst-kix_hbudgemy4svg-6>li:before{content:"\0025cf  "}ul.lst-kix_6qphcg6049xm-6{list-style-type:none}ul.lst-kix_6qphcg6049xm-8{list-style-type:none}.lst-kix_hbudgemy4svg-4>li:before{content:"\0025cb  "}.lst-kix_hbudgemy4svg-8>li:before{content:"\0025a0  "}.lst-kix_hbudgemy4svg-0>li:before{content:"\0025cf  "}.lst-kix_hbudgemy4svg-2>li:before{content:"\0025a0  "}ul.lst-kix_6qphcg6049xm-1{list-style-type:none}ul.lst-kix_6qphcg6049xm-0{list-style-type:none}ul.lst-kix_6qphcg6049xm-3{list-style-type:none}ul.lst-kix_6qphcg6049xm-2{list-style-type:none}ul.lst-kix_6qphcg6049xm-5{list-style-type:none}ul.lst-kix_6qphcg6049xm-4{list-style-type:none}.lst-kix_ioj6prcymh7w-7>li:before{content:"\0025cb  "}.lst-kix_ioj6prcymh7w-3>li:before{content:"\0025cf  "}.lst-kix_ioj6prcymh7w-1>li:before{content:"\0025cb  "}.lst-kix_ioj6prcymh7w-5>li:before{content:"\0025a0  "}ul.lst-kix_6d3ij62w2wog-3{list-style-type:none}ul.lst-kix_6d3ij62w2wog-4{list-style-type:none}ul.lst-kix_6d3ij62w2wog-5{list-style-type:none}ul.lst-kix_6d3ij62w2wog-6{list-style-type:none}ul.lst-kix_6d3ij62w2wog-0{list-style-type:none}ul.lst-kix_6d3ij62w2wog-1{list-style-type:none}ul.lst-kix_6d3ij62w2wog-2{list-style-type:none}ul.lst-kix_gp4xdxfwnezm-4{list-style-type:none}ul.lst-kix_gp4xdxfwnezm-3{list-style-type:none}ul.lst-kix_gp4xdxfwnezm-2{list-style-type:none}ul.lst-kix_gp4xdxfwnezm-1{list-style-type:none}ul.lst-kix_6d3ij62w2wog-7{list-style-type:none}ul.lst-kix_gp4xdxfwnezm-0{list-style-type:none}ul.lst-kix_6d3ij62w2wog-8{list-style-type:none}ul.lst-kix_xil4dpzhlcd1-8{list-style-type:none}ul.lst-kix_xil4dpzhlcd1-7{list-style-type:none}ul.lst-kix_xil4dpzhlcd1-6{list-style-type:none}.lst-kix_eczj93c02e14-0>li:before{content:"\0025cf  "}.lst-kix_eczj93c02e14-2>li:before{content:"\0025a0  "}ul.lst-kix_xil4dpzhlcd1-5{list-style-type:none}ul.lst-kix_xil4dpzhlcd1-4{list-style-type:none}ul.lst-kix_xil4dpzhlcd1-3{list-style-type:none}ul.lst-kix_xil4dpzhlcd1-2{list-style-type:none}.lst-kix_eczj93c02e14-1>li:before{content:"\0025cb  "}ul.lst-kix_xil4dpzhlcd1-1{list-style-type:none}ul.lst-kix_xil4dpzhlcd1-0{list-style-type:none}ul.lst-kix_gp4xdxfwnezm-8{list-style-type:none}ul.lst-kix_gp4xdxfwnezm-7{list-style-type:none}ul.lst-kix_gp4xdxfwnezm-6{list-style-type:none}ul.lst-kix_gp4xdxfwnezm-5{list-style-type:none}.lst-kix_gp4xdxfwnezm-3>li:before{content:"\0025cf  "}.lst-kix_gp4xdxfwnezm-5>li:before{content:"\0025a0  "}ul.lst-kix_cmozs3kyr76r-5{list-style-type:none}ul.lst-kix_cmozs3kyr76r-6{list-style-type:none}ul.lst-kix_cmozs3kyr76r-7{list-style-type:none}ul.lst-kix_cmozs3kyr76r-8{list-style-type:none}.lst-kix_gp4xdxfwnezm-2>li:before{content:"\0025a0  "}.lst-kix_gp4xdxfwnezm-6>li:before{content:"\0025cf  "}ul.lst-kix_cmozs3kyr76r-1{list-style-type:none}ul.lst-kix_cmozs3kyr76r-2{list-style-type:none}ul.lst-kix_cmozs3kyr76r-3{list-style-type:none}ul.lst-kix_cmozs3kyr76r-4{list-style-type:none}.lst-kix_gp4xdxfwnezm-1>li:before{content:"\0025cb  "}.lst-kix_gp4xdxfwnezm-7>li:before{content:"\0025cb  "}ul.lst-kix_cmozs3kyr76r-0{list-style-type:none}.lst-kix_gp4xdxfwnezm-0>li:before{content:"\0025cf  "}.lst-kix_gp4xdxfwnezm-8>li:before{content:"\0025a0  "}.lst-kix_eczj93c02e14-4>li:before{content:"\0025cb  "}.lst-kix_eczj93c02e14-3>li:before{content:"\0025cf  "}.lst-kix_gp4xdxfwnezm-4>li:before{content:"\0025cb  "}.lst-kix_eczj93c02e14-5>li:before{content:"\0025a0  "}.lst-kix_eczj93c02e14-6>li:before{content:"\0025cf  "}.lst-kix_eczj93c02e14-7>li:before{content:"\0025cb  "}.lst-kix_gui7t0bb9blf-1>li:before{content:"\0025cb  "}.lst-kix_gui7t0bb9blf-0>li:before{content:"\0025cf  "}.lst-kix_gui7t0bb9blf-2>li:before{content:"\0025a0  "}.lst-kix_eczj93c02e14-8>li:before{content:"\0025a0  "}.lst-kix_xil4dpzhlcd1-5>li:before{content:"\0025a0  "}.lst-kix_gui7t0bb9blf-8>li:before{content:"\0025a0  "}.lst-kix_xil4dpzhlcd1-1>li:before{content:"\0025cb  "}.lst-kix_gui7t0bb9blf-4>li:before{content:"\0025cb  "}.lst-kix_xil4dpzhlcd1-3>li:before{content:"\0025cf  "}.lst-kix_yrtyp8sld7dk-1>li:before{content:"\0025cb  "}.lst-kix_yrtyp8sld7dk-3>li:before{content:"\0025cf  "}.lst-kix_ctab4i83amx5-6>li:before{content:"\0025cf  "}.lst-kix_gui7t0bb9blf-6>li:before{content:"\0025cf  "}.lst-kix_xil4dpzhlcd1-7>li:before{content:"\0025cb  "}.lst-kix_ctab4i83amx5-8>li:before{content:"\0025a0  "}.lst-kix_yrtyp8sld7dk-5>li:before{content:"\0025a0  "}.lst-kix_hd03wv7eqjkl-0>li:before{content:"\0025cf  "}.lst-kix_ctab4i83amx5-4>li:before{content:"\0025cb  "}.lst-kix_ctab4i83amx5-2>li:before{content:"\0025a0  "}.lst-kix_yrtyp8sld7dk-7>li:before{content:"\0025cb  "}.lst-kix_ctab4i83amx5-0>li:before{content:"\0025cf  "}.lst-kix_hbudgemy4svg-3>li:before{content:"\0025cf  "}.lst-kix_hbudgemy4svg-7>li:before{content:"\0025cb  "}.lst-kix_ioj6prcymh7w-0>li:before{content:"\0025cf  "}.lst-kix_hbudgemy4svg-5>li:before{content:"\0025a0  "}.lst-kix_hbudgemy4svg-1>li:before{content:"\0025cb  "}.lst-kix_ioj6prcymh7w-6>li:before{content:"\0025cf  "}.lst-kix_ioj6prcymh7w-8>li:before{content:"\0025a0  "}.lst-kix_ioj6prcymh7w-2>li:before{content:"\0025a0  "}.lst-kix_ioj6prcymh7w-4>li:before{content:"\0025cb  "}ol{margin:0;padding:0}table td,table th{padding:0}.c4{margin-left:36pt;orphans:2;widows:2;padding-left:0pt}.c6{margin-left:72pt;orphans:2;widows:2;padding-left:0pt}.c0{orphans:2;widows:2;text-align:left}.c2{orphans:2;widows:2;height:11pt}.c18{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c7{orphans:2;widows:2}.c10{color:inherit;text-decoration:inherit}.c12{margin-left:108pt;padding-left:0pt}.c11{padding:0;margin:0}.c5{font-family:"Courier New"}.c8{page-break-after:avoid}.c3{font-weight:700}.c13{padding-bottom:4pt}.c14{font-family:"Consolas"}.c17{color:#1155cc}.c1{font-style:italic}.c15{text-decoration:underline}.c16{text-align:left}.c21{font-size:18pt}.c22{font-size:17pt}.c20{height:11pt}.c9{margin-left:36pt}.c19{text-align:center}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c18"><p class="c7 c19"><span class="c3 c21">CS111 - Project 2A: Races and Synchronization</span></p><h2 class="c7 c8" id="h.b4spxv7nnjbn"><span class="c3">INTRODUCTION:</span></h2><p class="c0"><span>In this project, you will engage (at a low level) with a range of synchronization problems. Part A of the project (this part!) deals with conflicting read-modify-write operations on single variables and complex data structures (an ordered linked list). &nbsp;It is broken up into multiple steps:</span></p><ul class="c11 lst-kix_hbudgemy4svg-0 start"><li class="c4 c16"><span>Part 1 - updates to a shared variable:</span></li></ul><ul class="c11 lst-kix_cmozs3kyr76r-0 start"><li class="c6 c16"><span>Write a multithreaded application (using pthreads) that performs parallel updates to a shared variable.</span></li><li class="c6 c16"><span>Demonstrate the race condition in the provided &ldquo;add&rdquo; routine, and address it with different synchronization mechanisms.</span></li><li class="c6 c16"><span>Do performance instrumentation and measurement.</span></li><li class="c6 c16"><span>Analyze and explain the observed performance.</span></li></ul><p class="c2"><span></span></p><ul class="c11 lst-kix_6qphcg6049xm-0 start"><li class="c4"><span>Part 2 - updates to a shared complex data structure:</span></li></ul><ul class="c11 lst-kix_6qphcg6049xm-1 start"><li class="c6"><span>Implement the four routines described in </span><span class="c17 c15"><a class="c10" href="https://www.google.com/url?q=https://drive.google.com/open?id%3D0B8f2cujmXkYXZE9CUVkyV3pLcjg&amp;sa=D&amp;ust=1476563305070000&amp;usg=AFQjCNEoBNQbRNVmmIiqYogtkeK_vrzY6w">SortedList.h</a></span><span>: </span><span class="c14">SortedList_insert, SortedList_delete, SortedList_lookup, </span><span>and</span><span class="c14">&nbsp;SortedList_length</span><span>.</span></li><li class="c6"><span>Write a multi-threaded application using pthread that performs parallel updates to a sorted doubly linked list data structure (using methods from the above step).</span></li><li class="c6"><span>Recognize and demonstrate the race conditions when performing linked list operations, and address them with different synchronization mechanisms.</span></li><li class="c6"><span>Do performance instrumentation and measurement.</span></li><li class="c6"><span>Analyze and explain the observed performance.</span></li></ul><p class="c0 c20"><span></span></p><h2 class="c7 c8" id="h.iyw8m88xpqom"><span class="c3">RELATION TO READING AND LECTURES:</span></h2><p class="c0"><span>The basic shared counter problem was introduced in section 28.1. </span></p><p class="c0"><span>Mutexes, test-and-set, spin-locks, and compare-and-swap were described in (many sections of) chapter 28.</span></p><p class="c0"><span>Synchronization of partitioned lists was introduced in section 29.2.</span></p><h2 class="c7 c8" id="h.i3c0no1u8fjw"><span class="c3">PROJECT OBJECTIVES:</span></h2><ul class="c11 lst-kix_gp4xdxfwnezm-0 start"><li class="c4"><span>primary: demonstrate the ability to recognize critical sections and address them with a variety of different mechanisms.</span></li><li class="c4"><span>primary: demonstrate the existence of race conditions, and efficacy of the subsequent solutions</span></li><li class="c4"><span>secondary: demonstrate the ability to deliver code to meet CLI and API specifications.</span></li><li class="c4"><span>secondary: experience with basic performance measurement and instrumentation</span></li><li class="c4"><span>secondary: experience with application development, exploiting new library functions, creating command line options to control non-trivial behavior.</span></li></ul><p class="c2"><span></span></p><h2 class="c7 c8" id="h.b1uj54esrw4u"><span class="c3">DELIVERABLES:</span></h2><p class="c7"><span>A single tarball (.tar.gz) containing:</span></p><ul class="c11 lst-kix_ctab4i83amx5-0 start"><li class="c4"><span>Four C source modules that compile cleanly (with no errors or warnings):</span></li></ul><ul class="c11 lst-kix_ctab4i83amx5-1 start"><li class="c6"><span class="c3">lab2_add.c</span><span>&nbsp;- a C program that implements and tests a shared variable add function, implements the (below) specified command line options, and produces the (below) specified output statistics.</span></li><li class="c6"><span class="c3">SortedList.h</span><span>&nbsp;- a header file (supplied by us) describing the interfaces for linked list operations.</span></li><li class="c6"><span class="c3">SortedList.c</span><span class="c1">&nbsp;- </span><span>a</span><span class="c1">&nbsp;</span><span>C module </span><span>that implements insert, delete, lookup, and length methods for a sorted doubly linked list (described in the provided header file, including correct placement of </span><span class="c1">yield</span><span>&nbsp;calls).</span></li><li class="c6"><span class="c3">l</span><span class="c3">ab2_list.c</span><span>&nbsp;- a C program that implements the (below) specified command line options and produces the (below) specified output statistics.</span></li></ul><ul class="c11 lst-kix_ctab4i83amx5-0"><li class="c4"><span>A </span><span class="c3">Makefile</span><span>&nbsp;to build the </span><span>deliverable programs, output, graphs, and tarball. &nbsp;For your early testing you are free to run your program manually, but by the time you are done, all of the below-described test cases should be executed, the output captured, and the graphs produced automatically. &nbsp;The higher level targets should be:</span></li></ul><ul class="c11 lst-kix_ctab4i83amx5-1 start"><li class="c6"><span class="c3">build</span><span>&nbsp;&hellip; compile all programs (default target)</span></li><li class="c6"><span class="c3">tests</span><span>&nbsp;&hellip; run all (over 200) specified test cases to generate results in CSV files. Note that the lab2_list program is expected to fail when running multiple threads without synchronization. &nbsp;Make sure that your Makefile continues executing despite such failures (e.g. put a &lsquo;-&rsquo; in front of commands that are expected to fail).</span></li><li class="c6"><span class="c3">graphs</span><span>&nbsp;&hellip; use </span><span class="c1">gnuplot(1)</span><span>&nbsp;and the supplied data reduction scripts to generate the required graphs</span></li><li class="c6"><span class="c3">tarball</span><span>&nbsp;&hellip; create the deliverable tarball</span></li><li class="c6"><span class="c3">clean</span><span>&nbsp;&hellip; delete all generated programs and output</span></li></ul><ul class="c11 lst-kix_ctab4i83amx5-0"><li class="c4"><span class="c3">lab2_add.csv</span><span>&nbsp;- containing all of your results for all of the Part-1 tests.</span></li><li class="c4"><span class="c3">lab2_list.csv</span><span>&nbsp;- containing all of your results for all of the Part-2 tests.</span></li><li class="c4"><span>graphs (</span><span class="c3">.png </span><span>files), created by </span><span class="c1">gnuplot(1) </span><span>on the above </span><span class="c3">csv</span><span>&nbsp;files with the supplied data reduction scripts:</span></li></ul><ul class="c11 lst-kix_ctab4i83amx5-1 start"><li class="c6"><span>For lab2_add</span></li></ul><ul class="c11 lst-kix_ctab4i83amx5-2 start"><li class="c7 c12"><span class="c3">lab2_add-1.png</span><span>&nbsp;...threads and iterations required to generate a failure (with and without yields)</span></li><li class="c7 c12"><span class="c3">lab2_add-2.png</span><span>&nbsp;&hellip; </span><span>Average time per operation with and without yields.</span></li><li class="c7 c12"><span class="c3">lab2_add-3.png</span><span>&nbsp;&hellip; Average time per (single threaded) operation vs. the number of iterations.</span></li><li class="c7 c12"><span class="c3">lab2_add-4.png</span><span>&nbsp;threads and iterations that can run successfully with yields under each of the three synchronization methods.</span></li><li class="c7 c12"><span class="c3">lab2_add-5.png</span><span>&nbsp;Average time per (multi-threaded) operation vs. the number of threads, for all four versions of the add function.</span></li></ul><ul class="c11 lst-kix_ctab4i83amx5-1"><li class="c6"><span>For lab2_list</span></li></ul><ul class="c11 lst-kix_ctab4i83amx5-2 start"><li class="c7 c12"><span class="c3">lab2_list-1.png</span><span>&nbsp;&hellip; </span><span>average time per (single threaded) unprotected operation vs. number of iterations (illustrating the correction of the per-operation cost for the list length).</span></li><li class="c7 c12"><span class="c3">lab2_list-2.png</span><span>&nbsp;&hellip; threads and iterations required to generate a failure (with and without yields).</span></li><li class="c7 c12"><span class="c3">lab2_list-3.png</span><span>&nbsp;&hellip; iterations that can run (protected) without failure.</span></li><li class="c7 c12"><span class="c3">lab2_list-4.png</span><span>&nbsp;&hellip; (corrected) average time per operation (for unprotected, mutex, and spin-lock) vs. number of threads.</span></li></ul><ul class="c11 lst-kix_ctab4i83amx5-0"><li class="c4"><span>a</span><span>&nbsp;</span><span class="c3">README.txt</span><span>&nbsp;file containing:</span></li></ul><ul class="c11 lst-kix_ctab4i83amx5-1 start"><li class="c6"><span>descriptions of each of the included files and any other information</span><span>&nbsp;about your submission that you would like to bring to our attention (e.g. limitation, features, testing methodology).</span></li><li class="c6"><span>brief (1-4 sentences per question) answers to each of the questions (below).</span></li></ul><h2 class="c7 c8" id="h.qbjdtqs3qbgv"><span class="c3">PROJECT DESCRIPTION:</span></h2><p class="c7"><span>To perform this assignment, you will need to learn a few things:</span></p><ul class="c11 lst-kix_yrtyp8sld7dk-0 start"><li class="c4"><span>pthread (</span><span class="c15 c17"><a class="c10" href="https://www.google.com/url?q=https://computing.llnl.gov/tutorials/pthreads/&amp;sa=D&amp;ust=1476563305093000&amp;usg=AFQjCNFR7vCbDXJF-jXKBorMRCsgSlIwbA">https://computing.llnl.gov/tutorials/pthreads/</a></span><span>)</span></li></ul><ul class="c11 lst-kix_eczj93c02e14-0 start"><li class="c4"><span>clock_gettime(2) &hellip; high resolution timers</span></li><li class="c4"><span>GCC atomic builtins (</span><span class="c17 c15"><a class="c10" href="https://www.google.com/url?q=http://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html&amp;sa=D&amp;ust=1476563305095000&amp;usg=AFQjCNHcN5y0V5cxr9ncQ9UaLaqoV__XTA">http://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html</a></span><span>)</span></li><li class="c4"><span class="c1">gnuplot(1)</span><span>&nbsp;&hellip; is a general and powerful tool for producing a wide variety of graphs, and is commonly used for organizing and reporting performance data. &nbsp;W</span><span>e are providing you with sample data reduction scripts</span><span>&nbsp;for the first parts of this assignment:</span></li></ul><ul class="c11 lst-kix_eczj93c02e14-1 start"><li class="c6"><span class="c17 c15"><a class="c10" href="https://www.google.com/url?q=https://drive.google.com/open?id%3D0B8f2cujmXkYXR1VrSlFLaVdoYnc&amp;sa=D&amp;ust=1476563305096000&amp;usg=AFQjCNHOrw_jl5AtakRkuY1hki3NtJ72Ug">lab2_add.gp</a></span></li><li class="c6"><span class="c17 c15"><a class="c10" href="https://www.google.com/url?q=https://drive.google.com/open?id%3D0B8f2cujmXkYXUVJGVWoxTm1YUTg&amp;sa=D&amp;ust=1476563305097000&amp;usg=AFQjCNHNqWXYO89OGHd-ERzxPjgiQtENGw">lab2_list.gp</a></span></li></ul><p class="c7 c9"><span>To use these scripts you will need a recent version of </span><span class="c1">gnuplot</span><span>&nbsp;installed on your system. &nbsp;</span></p><p class="c2 c9"><span></span></p><p class="c7 c9"><span>These scripts take no arguments, read </span><span class="c1">comma-separated value</span><span>&nbsp;(CSV) input files with standard names (</span><span class="c14">lab2_add.csv</span><span>, </span><span class="c14">lab2_list.csv</span><span>), and produce graphical output </span><span class="c14">.png</span><span>&nbsp;files with standard names.</span></p><p class="c2 c9"><span></span></p><p class="c7 c9"><span>In the next and final part of this assignment, you can use these as a basis for creating your own graphing scripts.</span></p><h3 class="c7 c8" id="h.6eool65lbu7k"><span>PART 1: adds to a shared variable</span></h3><p class="c2"><span></span></p><p class="c7"><span>Start with a basic add routine:</span></p><p class="c2"><span></span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5">void add(long long *pointer, long long value) {</span></p><p class="c7"><span class="c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long long sum = *pointer + value;</span></p><p class="c7"><span class="c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pointer = sum;</span></p><p class="c7"><span class="c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c2"><span class="c5"></span></p><p class="c7"><span>Write a test driver program called </span><span class="c3">lab2_add</span><span>&nbsp;that:</span></p><ul class="c11 lst-kix_gui7t0bb9blf-0 start"><li class="c4"><span>takes a parameter for the number of parallel threads (</span><span class="c3">--threads=</span><span>#, default 1)</span></li><li class="c4"><span>takes a parameter for the number of iterations (</span><span class="c3">--iterations=</span><span>#, default 1)</span></li><li class="c4"><span>initializes a (long long) counter to zero</span></li><li class="c4"><span>notes the (high resolution) starting time for the run (using </span><span class="c1">clock_gettime(2)</span><span>)</span></li><li class="c4"><span>starts the specified number of threads, each of which will use the above add function to</span></li></ul><ul class="c11 lst-kix_gui7t0bb9blf-1 start"><li class="c6"><span>add 1 to the counter the specified number of times</span></li><li class="c6"><span>add -1 to the counter the specified number of times</span></li><li class="c6"><span>exit to re-join the parent thread</span></li></ul><ul class="c11 lst-kix_gui7t0bb9blf-0"><li class="c4"><span>wait for all threads to complete, and notes the (high resolution) ending time for the run</span></li><li class="c4"><span>prints to stdout a comma-separated-value (CSV) record including</span></li></ul><ul class="c11 lst-kix_gui7t0bb9blf-1 start"><li class="c6"><span>t</span><span>he name of the test (&ldquo;add-none&rdquo; for the most basic usage)</span></li><li class="c6"><span>the number of threads (from </span><span class="c3">--threads=#</span><span>)</span></li><li class="c6"><span>the number of iterations (from </span><span class="c3">--iterations=#</span><span>)</span></li><li class="c6"><span>the total number of operations performed (threads x iterations x 2, the &ldquo;x 2&rdquo; factor because you add 1 first and then add -1)</span></li><li class="c6"><span>the total run time (in nanoseconds)</span></li><li class="c6"><span>the average time per operation (in nanoseconds).</span></li><li class="c6"><span>the total at the end of the run (0 if there were no conflicting updates)</span></li></ul><ul class="c11 lst-kix_gui7t0bb9blf-0"><li class="c4"><span>If the run completes successfully, exit with a return code of zero. &nbsp;If any errors (other than a non-zero final count) are encountered, exit with a non-zero exit code.</span></li></ul><p class="c2"><span></span></p><p class="c7"><span>The supported command line options and expected output are illustrated below:</span></p><p class="c2"><span></span></p><p class="c7 c9"><span class="c5">% ./lab2_add --iterations=10000 --threads=10</span></p><p class="c7 c9"><span class="c5">add-none,10,10000,200000,6574000,32,374</span></p><p class="c7 c9"><span class="c5">% </span></p><p class="c2"><span></span></p><p class="c7"><span>Run your program for ranges of </span><span class="c1">threads</span><span>&nbsp;(2, 4, 8, 12) and </span><span class="c1">iterations</span><span>&nbsp;(100, 1000, 10000, 100000) values, capture the output, and note how many threads and iterations it takes to (fairly consistently) result in a failure (non-zero sum). </span></p><p class="c2"><span></span></p><p class="c7"><span class="c3">QUESTION 2.1.1 - causing conflicts:</span></p><p class="c7 c9"><span class="c3">Why does it take many iterations before errors are seen?</span></p><p class="c7 c9"><span class="c3">Why does a significantly smaller number of iterations so seldom fail?</span></p><p class="c2"><span></span></p><p class="c2"><span></span></p><p class="c7"><span>There are ways to cause a thread to immediately yield (rather than waiting for a time slice end to preempt it). &nbsp;Posix includes a </span><span class="c14">sched_yield</span><span>&nbsp;operation, and Linux includes a </span><span class="c14">pthread_yield</span><span>&nbsp;operation. &nbsp;Extend the basic add routine to more easily cause the failures:</span></p><p class="c2"><span></span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5">int opt_yield;</span></p><p class="c2"><span></span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c5">void add(long long *pointer, long long value) {</span></p><p class="c7"><span class="c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long long sum = *pointer + value;</span></p><p class="c7"><span class="c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (opt_yield)</span></p><p class="c7"><span class="c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sched_yield();</span></p><p class="c7"><span class="c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pointer = sum;</span></p><p class="c7"><span class="c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c2"><span></span></p><p class="c7"><span>Add a new </span><span class="c3">--yield</span><span>&nbsp;option to your driver program that sets </span><span class="c5">opt_yield</span><span>&nbsp;to 1. &nbsp;If this option has been specified, each line of statistics output should begin with &ldquo;</span><span class="c3">add-yield</span><span>&rdquo;. &nbsp;Re-run your tests, with yields, for ranges of threads (2,4,8,12) and iterations (10, 20, 40, 80, 100, 1000, 10000, 100000), capture the output, and see how many iterations and threads it takes to (fairly consistently) result in a failure. &nbsp;It should now be much easier to cause the failures. &nbsp;</span></p><p class="c2"><span></span></p><p class="c7"><span>Compare the average execution time of the yield and non-yield versions a range threads (2, 8) and of iterations (100, 1000, 10000, 100000). You should note that the </span><span class="c3">--yield</span><span>&nbsp;runs are much slower than the non-yield runs. &nbsp;</span></p><p class="c2"><span></span></p><p class="c7"><span class="c3">QUESTION 2.1.2 - cost of yielding:</span></p><p class="c7 c9"><span class="c3">Why are the --yield runs so much slower? &nbsp;Where is the additional time going? &nbsp;Is it possible to get valid per-operation timings if we are using the --yield option? &nbsp;If so, explain how. &nbsp;If not, explain why not.</span></p><p class="c2"><span></span></p><p class="c7"><span>For a single thread, graph the average cost per operation (non-yield) as a function of the number of iterations. &nbsp;You should note that the average cost per operation goes down as the number of iterations goes up. &nbsp;</span></p><p class="c2"><span></span></p><p class="c7"><span>If you install </span><span class="c1">gnuplot(1)</span><span>&nbsp;and append all of your test output to a file called </span><span class="c3">lab2_add.csv</span><span>, you can use our sample data reduction scripts to produce this and all other required data plots.</span></p><p class="c2"><span></span></p><p class="c2"><span></span></p><p class="c7"><span class="c3">QUESTION 2.1.3 - measurement errors:</span></p><p class="c7 c9"><span class="c3">Why does the average cost per operation drop with increasing iterations?</span></p><p class="c7 c9"><span class="c3">If the cost per iteration is a function of the number of iterations, how do we know how many iterations to run (or what the &ldquo;correct&rdquo; cost is)?</span></p><p class="c2"><span class="c3"></span></p><p class="c7"><span>Implement three new versions of the add function:</span></p><ul class="c11 lst-kix_xil4dpzhlcd1-0 start"><li class="c4"><span>one protected by a pthread_mutex, enabled by a new </span><span class="c3">--sync=m</span><span>&nbsp;option. &nbsp;When running this test, the output statistics line should begin with &ldquo;add-m&rdquo; or &ldquo;add-yield-m&rdquo;.</span></li><li class="c4"><span>one protected by a spin-lock, enabled by a new </span><span class="c3">--sync=s</span><span>&nbsp;option. &nbsp;You will have to implement your own spin-lock operation. &nbsp;We suggest that you do this using the GCC </span><span class="c5">atomic __sync_ builtin</span><span>&nbsp;functions </span><span class="c3">__sync_lock_test_and_set </span><span>and </span><span class="c3">&nbsp;__sync_lock_release</span><span>. &nbsp;When running this test, the output statistics line should begin with &ldquo;add-s&rdquo; or &ldquo;add-yield-s&rdquo;.</span></li><li class="c4"><span>one that performs the add using the GCC </span><span class="c14">atomic __sync_ builtin</span><span>&nbsp;function </span><span class="c3">__sync_val_compare_and_swap</span><span>&nbsp;to ensure atomic updates to the shared counter, enabled by a new </span><span class="c3">--sync=c</span><span>&nbsp;option. &nbsp;When running this test, the output statistics line should begin with &ldquo;</span><span class="c3">add-c</span><span>&rdquo; or &ldquo;</span><span class="c3">add-yield-c</span><span>&rdquo;.</span></li></ul><p class="c2"><span></span></p><p class="c7"><span>Use your </span><span class="c3">--yield</span><span>&nbsp;option to confirm that, even for large numbers of threads (2, 4, 8, 12) and iterations (10,000 for mutexes and CAS, only 1,000 for spin locks) that reliably failed in the unprotected scenarios, all three of these serialization mechanisms eliminate the race conditions in the add critical section. &nbsp;Capture the output from these confirmation runs. &nbsp;[Note that we suggest a smaller number of threads/iterations when you test spin-lock synchronization]</span></p><p class="c2"><span></span></p><p class="c7"><span>Using a large enough number of iterations (e.g. 10,000) to overcome the issues raised in the question 2.1.3, test all four (no yield) versions (unprotected, mutex, spin-lock, compare-and-swap) for a range of number of threads (1,2,4,8,12) and capture the output. &nbsp;Graph the average time per operation (non-yield), vs the number of threads.</span></p><p class="c2"><span></span></p><p class="c7"><span class="c3">QUESTION 2.1.4 - costs of serialization:</span></p><p class="c7 c9"><span class="c3">Why do all of the options perform similarly for low numbers of threads?</span></p><p class="c2"><span class="c3"></span></p><p class="c7 c9"><span class="c3">Why do the three protected operations slow down as the number of threads rises?</span></p><p class="c2"><span class="c3"></span></p><p class="c7 c9"><span class="c3">Why are spin-locks so expensive for large numbers of threads?</span></p><h3 class="c7 c8" id="h.dqmb40vy1nv4"><span>PART 2: sorted, doubly-linked, list</span></h3><p class="c7"><span>Review the interface specifications for a sorted doubly linked list package described in the header file </span><span class="c17 c15"><a class="c10" href="https://www.google.com/url?q=https://drive.google.com/open?id%3D0B8f2cujmXkYXZE9CUVkyV3pLcjg&amp;sa=D&amp;ust=1476563305128000&amp;usg=AFQjCNH8tK83CQ7qzWbv9WdYm0r9078K5A">SortedList.h</a></span><span>, and implement all four methods in a new module named </span><span class="c3">SortedList.c</span><span>. &nbsp;Note that the interface includes three software-controlled yield options. &nbsp;</span><span class="c15">Identify the critical section in each of your four methods</span><span>, and add calls to </span><span class="c14">pthread_yield </span><span>or</span><span class="c14">&nbsp;sched_yield</span><span>, controlled by the yield options:</span></p><ul class="c11 lst-kix_6d3ij62w2wog-0 start"><li class="c4"><span>in SortedList_insert if opt_yield &amp; INSERT_YIELD</span></li><li class="c4"><span>in SortedList_delete if opt_yield &amp; DELETE_YIELD</span></li><li class="c4"><span>in SortedList_lookup if opt_yield &amp; LOOKUP_YIELD</span></li><li class="c4"><span>in SortedList_length if opt_yield &amp; LOOKUP_YIELD</span></li></ul><p class="c7"><span>to force a switch to another thread at the critical point in each method.</span></p><p class="c2"><span class="c5"></span></p><p class="c7"><span>Write a test driver program called </span><span class="c3">lab2_list</span><span>&nbsp;that:</span></p><ul class="c11 lst-kix_ioj6prcymh7w-0 start"><li class="c4"><span>takes a parameter for the number of parallel threads (</span><span class="c3">--threads=</span><span>#, default 1).</span></li><li class="c4"><span>takes a parameter for the number of iterations (</span><span class="c3">--iterations=</span><span>#, default 1).</span></li><li class="c4"><span>takes a parameter to enable (any combination of) optional critical section yields (</span><span class="c3">--yield</span><span>=[</span><span class="c3">idl</span><span>], </span><span class="c3">i</span><span>&nbsp;for insert, </span><span class="c3">d</span><span>&nbsp;for delete, and </span><span class="c3">l</span><span>&nbsp;for lookups).</span></li><li class="c4"><span>initializes an empty list.</span></li><li class="c4"><span>creates and initializes (with random keys) the required number (threads x iterations) of list elements. &nbsp;Note that we do this before creating the threads so that this time is not included in our start-to-finish measurement.</span></li><li class="c4"><span>notes the (high resolution) starting time for the run (using </span><span class="c1">clock_gettime(2)</span><span>).</span></li><li class="c4"><span>starts the specified number of threads.</span></li><li class="c4"><span>each thread:</span></li></ul><ul class="c11 lst-kix_ioj6prcymh7w-1 start"><li class="c6"><span>starts with a set of pre-allocated and initialized elements </span><span class="c3">(--iterations=#)</span></li><li class="c6"><span>inserts them all into a (single shared-by-all-threads) list</span></li><li class="c6"><span>gets the list length</span></li><li class="c6"><span>looks up and deletes each of the keys it had previously inserted</span></li><li class="c6"><span>exits to re-join the parent thread</span></li></ul><ul class="c11 lst-kix_ioj6prcymh7w-0"><li class="c4"><span>waits for all threads to complete, and notes the (high resolution) ending time for the run.</span></li><li class="c4"><span>checks the length of the list to confirm that it is zero.</span></li><li class="c4"><span>prints to stdout a comma-separated-value (CSV) record including:</span></li></ul><ul class="c11 lst-kix_ioj6prcymh7w-1 start"><li class="c6"><span>the name of the test, which is of the form: </span><span class="c3">list-</span><span class="c1">yieldopts</span><span class="c3">-</span><span class="c1">syncopts </span></li></ul><ul class="c11 lst-kix_ioj6prcymh7w-2 start"><li class="c7 c12"><span>where </span><span class="c1">yieldopts</span><span>&nbsp;= {</span><span class="c3">none</span><span>,</span><span class="c3">i,d</span><span>,</span><span class="c3">l,id,il,dl,idl</span><span>}</span></li><li class="c7 c12"><span>Where </span><span class="c1">syncopts</span><span>&nbsp;= {</span><span class="c3">none</span><span>,</span><span class="c3">s</span><span>,</span><span class="c3">m</span><span>}</span></li></ul><ul class="c11 lst-kix_ioj6prcymh7w-1"><li class="c6"><span>the number of threads (from </span><span class="c3">--threads=#</span><span>)</span></li><li class="c6"><span>the number of iterations (from </span><span class="c3">--iterations=#</span><span>)</span></li><li class="c6"><span>the number of lists (always 1 in this project)</span></li><li class="c6"><span>the total number of operations performed (threads x iterations x (insert + lookup &nbsp;+ delete))</span></li><li class="c6"><span>the total run time (in nanoseconds) for all threads</span></li><li class="c6"><span>the average time per operation (in nanoseconds).</span></li></ul><ul class="c11 lst-kix_ioj6prcymh7w-0"><li class="c4"><span>exits with a status of zero if there were no errors, otherwise non-zero</span></li></ul><p class="c2"><span></span></p><p class="c7"><span>In part one, a synchronization error merely resulted in the subtracts and adds not balancing out. &nbsp;In this part, a synchronization error is likely to result in a corrupted list. &nbsp;If, at any time, you find evidence of a corrupted list (e.g. you cannot find a key that you know you inserted, or the list length is not zero at the end of the test), you should log an error message (to stderr) and exit immediately without producing the above results record. &nbsp;Note that in some cases your program may not detect an error, but may simply experience a segmentation fault. &nbsp;When you look at your test results, you should consider any test that did not produce output to have failed.</span></p><p class="c2"><span></span></p><p class="c7"><span>The supported command line options and expected output are illustrated below:</span></p><p class="c7 c9"><span class="c5">% ./lab2-list --threads=10 --iterations=1000 --yield=id</span></p><p class="c7 c9"><span class="c5">list-id-none,10,1000,1,30000,527103247,25355</span></p><p class="c7 c9"><span class="c5">%</span></p><p class="c2"><span></span></p><p class="c7"><span>Run your program with a single thread, and increasing numbers of iterations (10, 100, 1000, 10000, 20000), capture the output, and note the average time per operation. These results should be quite different from what you observed when testing your add function with increasing numbers of iterations. &nbsp;Graph the time per operation vs the number of iterations (for </span><span class="c3">--threads=1</span><span>). &nbsp;</span></p><p class="c2"><span></span></p><p class="c7"><span>If you append all of your test output to a file called </span><span class="c3">lab2_list.csv</span><span>,</span><span>&nbsp;you can use the supplied data reduction script</span><span>&nbsp;</span><span>to produce this and all other required data plots.</span></p><p class="c2"><span></span></p><p class="c7"><span>You will observe that the time per iteration eventually becomes linear with the number of iterations! &nbsp;This is because the time to insert into or search a sorted list is proportional to the list length. &nbsp;This is to be expected &hellip; but we are primarily interested in the cost of serialization, and so we would like to separate the per operation costs from the per-element costs. &nbsp;The easiest way to do this is to divide the cost per iteration (total / (threads * iterations)) by the average search distance (iterations/4). &nbsp;Why iterations/4?</span></p><ul class="c11 lst-kix_hd03wv7eqjkl-0 start"><li class="c4"><span>Inserts take list length from 0 to iterations, and then from iterations to 0. &nbsp;Thus, the average list length is iterations/2.</span></li><li class="c4"><span>Each insert or search operation, on average, has to run through half the list, which gives us an average search distance of iterations/4.</span></li></ul><p class="c7"><span>With this correction, your program should (modulo startup time) report more stable per-operation costs. &nbsp;Note that the provided data reduction script graphs both the raw time per operation and the time corrected for the list length.</span></p><p class="c2"><span></span></p><p class="c7"><span>Run your program and see how many parallel threads (2,4,8,12) and iterations (10,100,1000) it takes to fairly consistently demonstrate a problem. &nbsp;Then run it again using various combinations of yield options and see how many threads (2,4,8,12) and iterations (2,4,8,16,32) it takes to fairly consistently demonstrate the problem. &nbsp;Make sure that you can demonstrate:</span></p><ul class="c11 lst-kix_tnb5cty5lfmx-0 start"><li class="c4"><span>conflicts between inserts (</span><span class="c3">--yield=i</span><span>)</span></li><li class="c4"><span>conflicts between deletes (</span><span class="c3">--yield=d</span><span>)</span></li><li class="c4"><span>conflicts between inserts and lookups (</span><span class="c3">--yield=il</span><span>)</span></li><li class="c4"><span>conflicts between deletes and lookups (</span><span class="c3">--yield=dl</span><span>)</span></li></ul><p class="c2"><span></span></p><p class="c7"><span>Add two new options to your program to call two new versions of these methods: one set of operations protected by pthread_mutexes (</span><span class="c3">--sync=m</span><span>), and another protected by test-and-set spin locks (</span><span class="c3">--sync=s</span><span>). &nbsp;Using your </span><span class="c3">--yield</span><span>&nbsp;options, demonstrate that either of these protections seems to eliminate all of the problems, even for large numbers of threads (12) and iterations (32).</span></p><p class="c2"><span></span></p><p class="c7"><span>Choose an appropriate number of iterations (e.g. 1000) to overcome start-up costs and rerun your program without the yields. &nbsp;Note that you will only be able to run the unprotected method for a single thread, but you should be able to run the protected methods for a wide range of numbers of threads (1, 2, 4, 8, 12, 16, 24). &nbsp;Graph the (corrected) per operation times (for each of the three synchronization options: unprotected, mutex, spin) vs the number of threads. &nbsp;</span></p><p class="c2"><span></span></p><p class="c7"><span class="c3">QUESTION 2.2.1 - scalability of Mutex</span></p><p class="c7 c9"><span class="c3">Compare the variation in time per protected operation vs the number of threads (for mutex-protected operations) in Part-1 and Part-2, commenting on similarities/differences and offering explanations for them.</span></p><p class="c2 c9"><span class="c3"></span></p><p class="c7"><span class="c3">QUESTION 2.2.2 - scalability of spin locks</span></p><p class="c7 c9"><span class="c3">Compare the variation in time per protected operation vs the number of threads for Mutex vs Spin locks, commenting on similarities/differences and offering explanations for them.</span></p><p class="c2"><span class="c3"></span></p><p class="c2"><span></span></p><h2 class="c7 c8" id="h.ntkctc6urrx7"><span class="c3">SUBMISSION:</span></h2><p class="c7"><span>Your tarball should have a name of the form lab2a-</span><span class="c1">studentID</span><span>.tar.gz and should be submitted via CCLE. </span></p><p class="c2"><span></span></p><p class="c7"><span>We will test it on a SEASnet GNU/Linux server running RHEL 7 (this is on lnxsrv09). You would be well advised to test your submission on that platform before submitting it.</span></p><h2 class="c7 c13" id="h.amuyeefgnkn7"><span class="c3 c22">RUBRIC:</span></h2><p class="c7"><span class="c3">Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Feature</span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c3">Packaging and build (10%)</span></p><p class="c7"><span>2</span><span>%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;untars expected contents </span></p><p class="c7"><span>3%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clean build w/default action (no warnings)</span></p><p class="c7"><span>3%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Makefile produces csv output, graphs, tarball</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reasonableness of README contents</span></p><p class="c2"><span></span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c3">Code review (20%)</span></p><p class="c7"><span>4%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overall readability and reasonableness</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add: yields correct and in appropriate places</span></p><p class="c7"><span>4%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list: yields correct and in appropriate places</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex correctly used for add</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex correctly used for list</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin lock correctly implemented and used for add</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin lock correctly implemented and used for list</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compare-and-swap correctly implemented and used to implement atomic add</span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c3">Results (50%) (reasonable run)</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add: threads and iterations</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add: correct output format</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add: reasonable time reporting</span></p><p class="c7"><span>3%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add: correct yield</span></p><p class="c7"><span>3%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add: correct mutex</span></p><p class="c7"><span>3%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add: correct spin</span></p><p class="c7"><span>3%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add: correct cas</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add: graphs (showed what we asked for)</span></p><p class="c2"><span></span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list: threads and iterations</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list: correct output format</span></p><p class="c7"><span>2%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list: reasonable time reporting</span></p><p class="c7"><span>6%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list: correct yield</span></p><p class="c7"><span>6%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list: correct mutex</span></p><p class="c7"><span>6%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list: correct spin</span></p><p class="c7"><span>6%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list: graphs (showed what we asked for)</span></p><p class="c2"><span></span></p><p class="c7"><span>Note: if your program does not accept the correct options or produce the correct output, you are likely to receive a zero for the results portion of your grade. &nbsp;Look carefully at the sample commands and output. &nbsp;If you have questions, ask your TA.</span></p><p class="c2"><span></span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c3">Analysis (20%) &hellip; (reasonably explained all results in README)</span></p><p class="c2"><span class="c3"></span></p><p class="c7"><span>4</span><span>%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;General clarity of thought and understanding</span></p><p class="c7"><span>2% each&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.1-2.1.4</span></p><p class="c7"><span>4% each&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1-2</span></p><p class="c2"><span></span></p></body></html>